---
slug: "/javascript-typing01"
layout: post
modified: 2022-03-14 00:09:35 +0900
date:   2021-09-08 18:28:12 +0900
title:  "[JAVASCRIPT] 한글 타이핑 효과 구현하기"
author: Kimson
categories: [ javascript ]
tags: [ effect, typing, 한글, til ]
image: assets/images/post/covers/TIL-javascript.png
description: "한글 타이핑 효과 구현

오늘은 한글 타이핑 효과를 구현해보려 합니다. 많은 노가다를 하다보니 알게 된 점이 몇 개 있고, 잘 작동 되는 모습에 굉장히 뿌듯함을 느꼈습니다.

많은 블로그에서 타이핑에 관한 효과를 소개하는데요. 구현하고자 하는 효과가 한 글자씩 뚝 뚝 나오는게 아닌 모음 자음의 분리된 형태로 쌓이는 효과를 원했습니다.

하지만 대부분이 글자 하나하나를 split하여 구현한 방식이고, 다른 블로그에서는 타이핑 효과를 주는 js 라이브러리를 사용하는 등의 방법을 알려주었습니다."
featured: false
hidden: false
rating: 5
toc: true
profile: false
keysum: false
keywords: ""
published: true
---

# 한글 타이핑 효과 구현

오늘은 한글 타이핑 효과를 구현해보려 합니다. 많은 노가다를 하다보니 알게 된 점이 몇 개 있고, 잘 작동 되는 모습에 굉장히 뿌듯함을 느꼈습니다.

많은 블로그에서 타이핑에 관한 효과를 소개하는데요. 구현하고자 하는 효과가 한 글자씩 뚝 뚝 나오는게 아닌 모음 자음의 분리된 형태로 쌓이는 효과를 원했습니다.

하지만 대부분이 글자 하나하나를 split하여 구현한 방식이고, 다른 블로그에서는 타이핑 효과를 주는 js 라이브러리를 사용하는 등의 방법을 알려주었습니다.

ToDo List에도 이미 올려버렸고, 구상해둔 방법이 있어서 일단 시작했습니다.

## 초성, 중성, 종성

먼저 한글을 분해하기 위해 한글의 구성을 짧게나마 알아야했습니다.

|예제|초성|중성|종성|
|:---:|:---:|:---:|:---:|
|킴|"ㅋ"|"ㅣ"|"ㅁ"|
{:.table}

초성의 종류는 ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'] 로 총 19개 입니다. 

중성의 종류는 ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'] 로 총 21개.

종성은 ['ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'] 로 총 27개 입니다.

위키백과의 [한글음절](https://ko.wikipedia.org/wiki/%ED%95%9C%EA%B8%80_%EC%9D%8C%EC%A0%88){:target="_blank"}를 보시면 자세하게 나와있습니다.

위키백과의 일부를 발췌하여 예를 들겠습니다.

```text
가각갂갃간갅갆갇갈갉갊갋갌갍갎갏감갑값갓갔강갖갗갘같갚갛
개객갞갟갠갡갢갣갤갥갦갧갨갩갪갫갬갭갮갯갰갱갲갳갴갵갶갷
...(중략)
기긱긲긳긴긵긶긷길긹긺긻긼긽긾긿김깁깂깃깄깅깆깇깈깉깊깋
까깍깎깏깐깑깒깓깔깕깖깗깘깙깚깛깜깝깞깟깠깡깢깣깤깥깦깧
```

초성 'ㄱ'ㅇ; 유지 되고 중성, 종성이 변하는 단위는 28입니다. 초성 'ㄱ'이 'ㄲ'로 바뀌는 단위는 중성 수 X 종성 수 = 588 입니다.

즉, 초성은 `588`개 마다 바뀌고, 중성은 `28`개, 종성은 `1`개 마다 바뀝니다.

유니코드 상에서 한글은 `ㄱ-힣` 까지 표기가 되며, `ㄱ`은 `12593`부터 `ㅎ`인 `12622`까지로 초성과 종성을 중복없이 합한 수인 29가지 가 나옵니다.

분명하게 영역을 나누기 위해 초, 중, 종성의 집합을 순차적으로 나타내겠습니다.

|초성|||중성|||
|구분|UniCode|인덱스|구분|UniCode|인덱스|
|:---:|:---:|:---:|:---:|:---:|:---:|
|ㄱ|12593|1|ㅏ|12623|1|
|ㄲ|12594|2|ㅐ|12624|2|
|ㄴ|12596|3|ㅑ|12625|3|
|ㄷ|12599|4|ㅒ|12626|4|
|ㄸ|12600|5|ㅓ|12627|5|
|ㄹ|12601|6|ㅔ|12628|6|
|ㅁ|12609|7|ㅕ|12629|7|
|ㅂ|12610|8|ㅖ|12630|8|
|ㅃ|12611|9|ㅗ|12631|9|
|ㅅ|12613|10|ㅘ|12632|10|
|ㅆ|12614|11|ㅙ|12633|11|
|ㅇ|12615|12|ㅚ|12634|12|
|ㅈ|12616|13|ㅛ|12635|13|
|ㅉ|12617|14|ㅜ|12636|14|
|ㅊ|12618|15|ㅝ|12637|15|
|ㅋ|12619|16|ㅞ|12638|16|
|ㅌ|12620|17|ㅟ|12639|17|
|ㅍ|12621|18|ㅠ|12640|18|
|ㅎ|12622|19|ㅡ|12641|19|
|&nbsp;|&nbsp;|&nbsp;|ㅢ|12642|20|
|&nbsp;|&nbsp;|&nbsp;|ㅣ|12643|21|
{:.table}

종성은 생략하겠습니다. 중요한 건 '가'의 시작부터 '힣'까지의 패턴을 코드화 하는 것 입니다.

먼저 이미 입력된 글을 분해하는 것부터 하겠습니다. 한 글자만 분해해도 여러글자는 for문으로 처리해서 스택에 쌓으면 됩니다.

```html
<h1>한글 분해 / 조합 테스트</h1>
<div id="output"></div>
```

`html`은 테스트용으로 `output`이라는 아이디를 가진 `div`태그에 출력하겠습니다.

```javascript
let f = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];

let m = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];

let l = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
// 초, 중, 종성을 각 배열을 만들어 담습니다.
// first, middle, last의 첫 자를 땄습니다.

let math = '가'.charCodeAt()-44032;
// 글자의 유니코드를 순번화 하기 위해 '가'의 시작 유니코드인 44032를 뺍니다.

let ft = Math.floor(math/588);
// 초성은 588개 단위로 변한다.

let mt = Math.floor((math-(ft*588))/28);
// 중성은 해당 글자의 유니코드에서 초성 시작 순번을 빼고, 종성의 개수로 나누어 종성이 시작하는 때의 중성을 찾습니다.

let lt = Math.floor(math%28);
// 종성은 28개 단위로 반복되며, 글자의 유니코드를 28로 나누었을 때 나머지가 종성의 순번이 됩니다.

let tmp;
tmp = [f[ft], m[mt], l[lt]];
console.log(tmp); // (3) ['ㄱ', 'ㅏ', '']
// 해당되는 인덱스 번호의 글을 출력해봅니다.
document.getElementById('output').innerHTML = tmp;
```
{:id="han01"}

![한글]({{site.baseurl}}/assets/images/post/hangul/han02.png)

"가"와 "힣" 까지 나오는 것을 보니 잘 작동합니다.

하지만 이렇게 분해해서는 타이핑 효과를 보기가 힘듭니다. 그래서 생각이 든 과정이 아래와 같습니다.

1. 분해된 글자를 재 조립하면서 배열에 [ 초성, 초+중성, 초+중+종성 ]으로 담습니다.
2. "힣"을 예로 들면 [ "ㅎ", "히", "힣" ]으로 배열에 담겨 한 글자씩 적는 효과를 줍니다.
3. 타겟(출력)이 되는 태그에 스택되면서 완성된 글 다음에 타이핑 하는 효과를 구현합니다.

## 한글 음절의 재조합

```javascript
// 위 코드에서 배열로 받아 처리할 것이기 때문에 forEach를 사용했습니다.
// ex >> data = ['ㅋ','ㅣ','ㅁ'];
data.forEach(x=>{
	let tmp = [];
	let sf = f.indexOf(x[0])*588;
	let sm = m.indexOf(x[1])*28;
	let sl = l.indexOf(x[2])%28;
	if(x[1]=='' && x[2]==''){
		// 자음 하나만 있을 경우 인덱스로 바로 담음
		tmp.push(f[f.indexOf(x[0])]);
	} else {
		// 초, 중, 종성 다 있으면 유니코드->글자 변환
		tmp.push(String.fromCharCode(sf+sm+sl+44032)); // 7028
	}
	console.log(tmp);
	document.getElementById('output').innerHTML = tmp;
});
```
{:id="han02"}

다시 재조합하기 위해 글자의 유니코드를 다시 역으로 맞춰야합니다. 역으로 유니코드를 맞추고나면 `String`의 내장함수인 `fromCharCode()`를 사용하여 글자로 다시 변환합니다.

위의 코드로 테스트를 해보면 아래 이미지처럼 나와야 성공입니다.

![한글]({{site.baseurl}}/assets/images/post/hangul/han03.png)

이제 조합에 성공했으니 낱자 배열`( ['ㅂ', 'ㅏ', 'ㅂ'] )`을 3단계로 조합하여 다시 배열에 담습니다.

> 초성 하나 일때 인덱스로 바로 넣는 이유는 초성이 시작하는 'ㄱ'의 `유니코드(12593)`가 글자 시작인 '가'의 `유니코드(44032)`와 다르기 때문입니다.

```javascript
// data에 낱자 3개씩 묶인 배열을 받습니다. ex >> ['ㅂ','ㅏ','ㅂ']
let ref = [];
data.forEach(x=>{
	let a=[x[0],'',''];
	let b=[x[0],x[1],''];
	let c=[x[0],x[1],x[2]];
	if(x[2]!=''){
		ref = [...ref, [a,b,c]];
	} else {
		ref = [...ref, [a,b]];
	}
});
console.log(ref);
```

"밥"이라는 글자를 분해한 배열을 `data`에 넣고 변환시킵니다.

1. `a`변수 = ['ㅂ', '', '']
2. `b`변수 = ['ㅂ', 'ㅏ', '']
3. `c`변수 = ['ㅂ', 'ㅏ', 'ㅂ']

이것을 배열로 한번 더 감싸서 2차 배열로 만들어 `ref`에 담습니다. 이제 3차 배열이 된 ref를 재조합한 로직으로 다시 보냅니다.

![한글]({{site.baseurl}}/assets/images/post/hangul/han04.png)

이때 아까 만들었던 재조합 로직은 배열 하나를 대상으로 하기 때문에 for문을 하나 더 감싸서 3차 배열에 대한 작동을 고려해야합니다. 이 부분은 그저 한번 더 감싸면 되기 때문에 코드는 생략하겠습니다.

순차로 합쳐진 문자 배열을 재조합 로직에 넣고 돌리면 아래와 같습니다.

![한글]({{site.baseurl}}/assets/images/post/hangul/han05.png)

드디어 생각만 했던 로직이 정상 작동되어 매우 뿌듯합니다. 이제 이 데이터를 타이핑처럼 하나씩 쌓이는 출력 효과만 남았습니다.

## 타이핑 효과

이 부분에서 엄청 고민 많이 했습니다. 앞에 로직을 하는데 에너지를 써서 그런지 많이 버벅거렸습니다.

타이핑은 시간간격을 두고 작성이 되는데 인터벌을 두개 쓰자니 중복 실행되고, for문을 두 개 돌리자니 순식간에 그냥 결과만 도출하니 왜 고생했나 싶고...

```javascript
let tmp = '';
let repo = '';
let i=0;
let q=0;
let tps = setInterval(()=>{
	tmp = data[i][q]; // tmp에 글자의 배열을 하나씩 넣어 초기화한다.
	q++;
	tp.innerHTML = repo+tmp; // repo라는 stack 변수와 tmp를 합하여 출력한다.
	if(q>data[i].length-1){
		// 글자의 완성형을 출력한 뒤면 다시 q를 0으로 초기화 시킨다
		q=0;
		// 글자가 끝났으니 다음 글자를 가져오기 위해 i증가
		i++;
		repo+=tmp; // 완성된 글을 repo에 하나씩 담는다.
	}
	if(i>data.length-1){ // 모든 글이 출력되면 인터벌 종료
		clearInterval(tps);
	}
},200); // 0.2초 마다 타이핑 하나씩 한다.
```

그래서 인터벌 하나만 썼습니다. 각 단어마다 배열을 나누었기 때문에 단어의 마지막인 완성형에서 다음 2차배열을 가져와 다시 뿌리면 되는 간단한 것이었습니다.

마지막으로 타이핑 되는 효과는 gif로 담아봤습니다.

![한글]({{site.baseurl}}/assets/images/post/hangul/han06.gif)

스페이스 바 등의 공백과 특수문자는 로직 중간에 거르거나 공백란으로 변환시키면 될 것 같습니다.

영문은 이러한 유니코드 변환 작업 없이 그냥 담아서 쓰면 되기 때문에 적절히 함수화 하여 조합하면 모든 문자에 대한 타이핑 효과를 만들어 낼 수 있을 것이라 생각됩니다.

여기까지 읽어주셔서 감사드립니다. 여러분의 소소한 댓글 하나가 저에게 힘이 됩니다.

-----