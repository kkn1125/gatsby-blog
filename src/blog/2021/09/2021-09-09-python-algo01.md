---
slug: "/python-algo01"
layout: post
modified: 2022-03-14 00:09:35 +0900
date:   2021-09-09 12:07:32 +0900
title:  "[PYTHON] 프로젝트 오일러 1번 문제"
author: Kimson
categories: [ python ]
tags: [ til, 오일러 ]
image: assets/images/post/covers/TIL-python.jpg
description: "문제를 읽고 보면 이미 `or`로 조건을 걸어 더하기를 해주면 되는 쉬운 문제입니다.

또는 5이기 때문에 인자를 두 개 받고, `limit`미만까지 돌아 해당되는 수를 더하여 출력합니다.
 
그런데 이러한 문제들을 풀다보니 프로그램 실행 속도와 여러 공식을 보다보니 문득 생각이 들었습니다."
featured: false
hidden: false
rating: 5
toc: true
profile: false
keysum: false
keywords: ""
published: true
---

# 1번 문제

> 10보다 작은 자연수 중에서 3 또는 5의 배수는 3, 5, 6, 9 이고, 이것을 모두 더하면 23입니다.
> 1000보다 작은 자연수 중에서 3 또는 5의 배수를 모두 더하면 얼마일까요?

문제를 읽고 보면 이미 `or`로 조건을 걸어 더하기를 해주면 되는 쉬운 문제입니다.

```python
limit = 1000
sum = 0

def sum_multi(a, b):
    global sum
    for i in range(1, limit):
        if i % a == 0 or i % b == 0:
            sum += i
    return sum
```

3 또는 5이기 때문에 인자를 두 개 받고, `limit`미만까지 돌아 해당되는 수를 더하여 출력합니다.

![오일러]({{site.baseurl}}/assets/images/post/algo/algo01.png)

그런데 이러한 문제들을 풀다보니 프로그램 실행 속도와 여러 공식을 보다보니 문득 생각이 들었습니다.

1. `limit` 값이 높을 때는 얼마나 시간이 걸릴까?
2. 공식을 만들어 시간복잡도를 줄일 수 없을까?

## 배수 합을 구하는 공식 세우기

순차 합계인 `1 + 2 + 3 ... + n` 의 합을 구하는 공식은 모두가 아실겁니다. 그런데 배수의 합을 구하는 공식이 있지 않을까? 해서 끄적이던 결과 하나의 공식이 나오는 것을 알 수 있었습니다.

범위의 수인 `limit`가 정하질 때 `s`의 배수 합을 구한다고 가정하면, 총 `limit` 범위 안의 `s`배수의 개수는 `n`로 가정합니다.

만일 `s = 5`이고 `limit = 33`이라면 32의 범위 안에서 5의 배수의 합을 구해야합니다.

[5, 10, 15, 20, 25, 30]이 나오게 되고, 여기서 양 끝의 합을 구하면 35로 동일하게 3개가 나옵니다. 즉, 35 * 3이 됩니다.

여기서 이것을 문자로 바꾸어 공식을 세우면 `(s * n) + s` 가 35이고, 3이 `n`개의 절반이라는 것으로 가정할 수 있습니다.

전체 공식을 쓰면, `((s * n) + s) * n / 2`입니다.

더 정제하면 `(s * (n^2 + n)) / 2`으로 정리가 됩니다. 테스트로 다른 수와 `limit`를 달리하여 검증해보니 결과를 잘 도출합니다.

## 적용

하지만 이 식을 그대로 3을 넣고 5를 넣어 합산한 수를 더하면 오답이 나옵니다. 문제를 잘 보면 3 또는 5의 배수이므로 3과 5의 공통된 배수인 15 배수의 합을 제외해야 합니다.

코드로 보면 이렇습니다.

```python
limit = 1000
sum = 0
def sum_multi(a, b):
    global sum

    c = a*b # 15 배수

    n = (limit-1)//a
    sum += int((a*(n+1)*n)/2)

    n = (limit-1)//b
    sum += int((b*(n+1)*n)/2)

    n = (limit-1)//c # 15배수 합
    sum -= int((c*(n+1)*n)/2) # 15배수 합을 전체 합에서 제외

    return sum
```

답은 처음 `for`문과 `if`문을 쓴 것과 동일한 결과가 나옵니다. 하지만 결과를 출력하는 시간의 차이는 어마어마하다는 것을 발견할 수 있습니다.

`limit`가 `1000`일 때는 두 코드 다 비슷한 `0.18 ~ 0.27 밀리초` 입니다.

그런데 `limit`가 `100000 ~ 100000000` 이라면 이야기가 달라집니다.

`100000000`일 때 비교를 해보겠습니다.

![오일러]({{site.baseurl}}/assets/images/post/algo/algo03.png)

동일 조건에서 `for`문이 있는 함수는 7148.68 밀리초가 걸립니다. 즉, 7.1초가 걸립니다.

![오일러]({{site.baseurl}}/assets/images/post/algo/algo02.png)

공식을 세운 `for`문이 없는 함수는 0.23 밀리초가 걸립니다. 이 차이는 약 31,081배의 속도 차이가 나는 것 입니다.

## 결론

되도록 귀찮더라도 해당 문제에 패턴이나 원리를 찾아내보는 시간을 가져보는 것도 좋을 것 같습니다. 이러한 공식을 있는 공식에서 찾아 쓰는 것도 좋지만 찾지 않고, 생각 해보면서 공식을 찾아가는 것이 더 머리에 잘 남고 뿌듯해지는 것 같습니다.

그리고 무엇보다도 공식이 생기면 불필요한 for문이 사라지고 코드가 길어지더라도 효율성이 이번 예제처럼 3만 배가 증가하니... (물론 케이스 별로 다르겠습니다만)